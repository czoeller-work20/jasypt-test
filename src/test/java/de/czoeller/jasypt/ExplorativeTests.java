package de.czoeller.jasypt;

import org.jasypt.digest.StandardStringDigester;
import org.jasypt.util.digest.Digester;
import org.jasypt.util.password.BasicPasswordEncryptor;
import org.jasypt.util.text.BasicTextEncryptor;
import org.jasypt.util.text.StrongTextEncryptor;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.nio.charset.StandardCharsets;

import static org.assertj.core.api.Assertions.assertThat;


/**
 * Use jasypt library explorative to understand how to use it.
 *
 * @author czoeller
 */
public class ExplorativeTests {

    @Nested
    @DisplayName("Text")
    class Text {
        @Test
        public void simpleEncryption() {
            BasicTextEncryptor textEncryptor = new BasicTextEncryptor();
            String myData = "Hello World";
            String key = "secretKey";
            textEncryptor.setPasswordCharArray(key.toCharArray());

            String encrypted = textEncryptor.encrypt(myData);
            String decrypted = textEncryptor.decrypt(encrypted);

            System.out.println(encrypted);
            assertThat(encrypted).isNotEmpty();
            assertThat(decrypted).isEqualTo(myData);
        }

        @Test
        public void strongEncryption() {
            StrongTextEncryptor textEncryptor = new StrongTextEncryptor();
            String myData = "Hello World";
            String key = "secretKey";
            textEncryptor.setPasswordCharArray(key.toCharArray());

            String encrypted = textEncryptor.encrypt(myData);
            String decrypted = textEncryptor.decrypt(encrypted);

            System.out.println(encrypted);
            assertThat(encrypted).isNotEmpty();
            assertThat(decrypted).isEqualTo(myData);
        }
    }

    @Nested
    @DisplayName("Password")
    class Password {
        /**
         * This is actually hashing (one-way-function).
         * Used for hashing a password. Given H(x) = y
         * 1. there is no way to find x for a given y. H(x) -> y
         * 2. there is no way to find for a given x a x' that produce the same output. H(x) = H(x'), x != x'
         */
        @Test
        public void oneWayEncryption() {
            BasicPasswordEncryptor passwordEncryptor = new BasicPasswordEncryptor();
            String password = "Hello World";

            String hash = passwordEncryptor.encryptPassword(password);

            System.out.println(hash);
            assertThat(hash).isNotEmpty();
            assertThat(passwordEncryptor.checkPassword(password, hash)).isTrue();
            assertThat(passwordEncryptor.checkPassword("wrong password", hash)).isFalse();
        }
    }

    /*
     * The purpose of a digest is hard to show in the unit tests, because the digest can be transmitted on a
     * second communication channel and is calculable by the server and the client as well.
     */
    @Nested
    @DisplayName("Digest")
    class Digest {
        /*
         * A message digest algorithm takes a single input -- a message -- and produces a "message digest" (aka hash)
         * which allows you to verify the integrity of the message: Any change to the message will (ideally) result in
         * a different hash being generated.
         * An attacker that can replace the message and digest is fully capable of replacing the message and digest
         * with a new valid pair.
         */
        @Test
        public void generateDigest() {
            final Digester digester = new Digester();
            String myData = "Hello World";
            final byte[] digest = digester.digest(myData.getBytes(StandardCharsets.UTF_8));
            System.out.println(digest);
            assertThat(digest).isNotEmpty();
        }

        /*
         * A MAC algorithm takes two inputs -- a message and a secret key -- and produces a MAC which allows
         * you to verify the integrity and the authenticity of the message: Any change to the message or the secret
         * key will (ideally) result in a different MAC being generated.
         *
         * Nobody without access to the secret should be able to generate a MAC calculation that verifies;
         * in other words a MAC can be used to check that the MAC was generated by a party that
         * has access to the secret key.
         */
        @Test
        public void generateMAC() {
            final StandardStringDigester stringDigester = new StandardStringDigester();
            final StandardStringDigester stringDigester2 = new StandardStringDigester();

            String myData = "Hello World";

            // message and digest would be not transmitted on the same communication channel afaik.
            final String digest = stringDigester.digest(myData);
            assertThat(stringDigester.matches(myData, digest)).isTrue();
            System.out.println(digest);

            final String digest2 = stringDigester2.digest(myData);
            assertThat(digest).isNotEqualTo(digest2);
            assertThat(stringDigester.matches(myData, digest2)).isTrue();
        }
    }
}
